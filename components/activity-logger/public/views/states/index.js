/**
 * States View
 * Main view for state management with graph visualization
 */

/**
 * Auto-generate states from events
 */
async function autoGenerateStates(silent = false) {
  if (!window.stateService) {
    if (!silent) alert('State service not available');
    return;
  }

  const btn = document.getElementById('autoGenerateBtn');
  if (btn) {
    btn.disabled = true;
    btn.innerHTML = '<span>⏳</span> Generating...';
  }

  try {
    const workspacePath = window.state?.currentWorkspace || null;
    
    const response = await fetch(`${window.CONFIG.API_BASE}/api/states/auto-generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        workspace_path: workspacePath,
        options: {
          minEventsPerState: 3,
          maxTimeGapMinutes: 30
        }
      })
    });

    if (!response.ok) {
      // Handle non-JSON error responses
      const errorText = await response.text();
      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.error || errorMessage;
      } catch (e) {
        // Not JSON, use the text as-is
        if (errorText) errorMessage = errorText;
      }
      
      if (!silent) {
        alert(`Error: ${errorMessage}`);
      }
      return;
    }

    let result;
    try {
      result = await response.json();
    } catch (parseError) {
      // Handle non-JSON responses even when response.ok is true
      console.warn('[STATES-VIEW] Error parsing JSON response:', parseError);
      if (!silent) {
        alert(`Error: Unable to parse server response`);
      }
      return;
    }

    if (result && result.success) {
      window.statesAutoGenerated = true;
      
      if (!silent && result.count > 0) {
        alert(`Generated ${result.count} state${result.count !== 1 ? 's' : ''} from your activity!`);
      }
      
      // Refresh views
      await renderStatesList();
      if (window.stateGraph) {
        await window.stateGraph.loadAndRender(workspacePath);
      }
    } else {
      if (!silent) {
        alert(`Error: ${result.error || 'Failed to generate states'}`);
      }
    }
  } catch (error) {
    console.error('[STATES-VIEW] Error auto-generating states:', error);
    if (!silent) {
      alert(`Error: ${error.message}`);
    }
  } finally {
    if (btn) {
      btn.disabled = false;
      btn.innerHTML = '<span></span> Auto-Generate States';
    }
  }
}

async function renderStatesView(container) {
  container.innerHTML = `
    <div class="states-view">
      <div class="states-view-header">
        <h2>State Management</h2>
        <div class="states-view-actions">
          <button class="btn btn-primary" onclick="autoGenerateStates()" id="autoGenerateBtn">
            <span></span> Auto-Generate States
          </button>
          <button class="btn btn-secondary" onclick="createNewState()">
            <span>+</span> Create State
          </button>
          <button class="btn btn-secondary" onclick="refreshStateGraph()">
            <span>↻</span> Refresh
          </button>
        </div>
      </div>
      
      <div class="states-view-content">
        <div id="stateGraphContainer" class="state-graph-container"></div>
        
        <div class="states-list-container">
          <h3>All States</h3>
          <div id="statesList" class="states-list"></div>
        </div>
      </div>
    </div>
  `;

  // Auto-generate states on first load if none exist
  if (!window.statesAutoGenerated) {
    try {
      const states = await window.stateService?.listStates({
        workspace_path: window.state?.currentWorkspace
      }) || [];
      
      if (states.length === 0) {
        // Auto-generate states in background
        setTimeout(async () => {
          await autoGenerateStates(true); // Silent mode
        }, 1000);
      }
    } catch (error) {
      console.debug('[STATES-VIEW] Could not check existing states:', error.message);
    }
  }

  // Load and render state graph
  if (window.StateGraphVisualization && window.d3) {
    window.stateGraph = new window.StateGraphVisualization('stateGraphContainer', {
      width: container.offsetWidth || 1200,
      height: 600
    });
    
    // Get current workspace
    const workspacePath = window.state?.currentWorkspace || null;
    await window.stateGraph.loadAndRender(workspacePath);
  } else {
    console.warn('[STATES-VIEW] D3.js or StateGraphVisualization not available');
    document.getElementById('stateGraphContainer').innerHTML = 
      '<div class="empty-state">Loading state graph visualization...</div>';
  }

  // Load and render states list
  await renderStatesList();
}

/**
 * Render states list
 */
async function renderStatesList() {
  const container = document.getElementById('statesList');
  if (!container) return;

  if (!window.stateService) {
    container.innerHTML = '<div class="empty-state">State service not available</div>';
    return;
  }

  try {
    const states = await window.stateService.listStates({
      workspace_path: window.state?.currentWorkspace
    });

    if (states.length === 0) {
      container.innerHTML = '<div class="empty-state">No states yet. Create your first state!</div>';
      return;
    }

    const escapeHtml = window.escapeHtml || ((str) => {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    });

    let html = '';
    states.forEach(state => {
      const intent = state.metadata?.intent || 'general';
      const intentColors = {
        'experiment': '#FF6B6B',
        'feature': '#4ECDC4',
        'bug-fix': '#FFE66D',
        'refactor': '#95E1D3',
        'optimization': '#F38181',
        'general': '#C7CEEA'
      };

      html += `
        <div class="state-list-item" data-state-id="${state.id}">
          <div class="state-list-item-header">
            <div class="state-list-item-name">${escapeHtml(state.name)}</div>
            <div class="state-list-item-actions">
              <button class="btn-icon" onclick="switchToState('${state.id}')" title="Switch to this state">
                <span>→</span>
              </button>
              <button class="btn-icon" onclick="forkState('${state.id}')" title="Fork this state">
                <span>↗</span>
              </button>
            </div>
          </div>
          <div class="state-list-item-description">${escapeHtml(state.description || '')}</div>
          <div class="state-list-item-meta">
            <span class="state-intent-badge" style="background: ${intentColors[intent] || intentColors.general}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8em;">
              ${escapeHtml(intent)}
            </span>
            ${state.metadata?.tags && state.metadata.tags.length > 0 ? `
              <span class="state-tags">
                ${state.metadata.tags.map(tag => `<span class="tag">#${escapeHtml(tag)}</span>`).join('')}
              </span>
            ` : ''}
            <span class="state-date">${new Date(state.created_at).toLocaleDateString()}</span>
          </div>
        </div>
      `;
    });

    container.innerHTML = html;
  } catch (error) {
    console.error('[STATES-VIEW] Error loading states:', error);
    container.innerHTML = `<div class="error-state">Error loading states: ${error.message}</div>`;
  }
}

/**
 * Create new state
 */
async function createNewState() {
  const name = prompt('Enter state name:');
  if (!name) return;

  const description = prompt('Enter state description (optional):') || '';

  if (!window.stateService) {
    alert('State service not available');
    return;
  }

  try {
    const state = await window.stateService.createState(name, description, {
      workspace_path: window.state?.currentWorkspace
    });

    if (state) {
      alert(`State "${state.name}" created!`);
      // Refresh views
      await renderStatesList();
      if (window.stateGraph) {
        await window.stateGraph.loadAndRender(window.state?.currentWorkspace);
      }
    }
  } catch (error) {
    console.error('[STATES-VIEW] Error creating state:', error);
    alert(`Error: ${error.message}`);
  }
}

/**
 * Switch to state
 */
async function switchToState(stateId) {
  if (!window.stateService) {
    alert('State service not available');
    return;
  }

  try {
    const states = await window.stateService.listStates();
    const state = states.find(s => s.id === stateId);
    if (!state) {
      alert('State not found');
      return;
    }

    const result = await window.stateService.executeCommand(`switch to ${state.name}`, {});
    if (result.success) {
      alert(`Switched to state: ${state.name}`);
      if (window.stateGraph) {
        window.stateGraph.setCurrentState(stateId);
        await window.stateGraph.loadAndRender(window.state?.currentWorkspace);
      }
    }
  } catch (error) {
    console.error('[STATES-VIEW] Error switching state:', error);
    alert(`Error: ${error.message}`);
  }
}

/**
 * Fork state
 */
async function forkState(stateId) {
  if (!window.stateService) {
    alert('State service not available');
    return;
  }

  const name = prompt('Enter name for forked state:');
  if (!name) return;

  const description = prompt('Enter description (optional):') || '';

  try {
    const forked = await window.stateService.forkState(stateId, name, description);
    if (forked) {
      alert(`Forked state "${forked.name}"`);
      // Refresh views
      await renderStatesList();
      if (window.stateGraph) {
        await window.stateGraph.loadAndRender(window.state?.currentWorkspace);
      }
    }
  } catch (error) {
    console.error('[STATES-VIEW] Error forking state:', error);
    alert(`Error: ${error.message}`);
  }
}

/**
 * Refresh state graph
 */
async function refreshStateGraph() {
  if (window.stateGraph) {
    await window.stateGraph.loadAndRender(window.state?.currentWorkspace);
  }
  await renderStatesList();
}

// Export
if (typeof window !== 'undefined') {
  window.renderStatesView = renderStatesView;
  window.createNewState = createNewState;
  window.switchToState = switchToState;
  window.forkState = forkState;
  window.refreshStateGraph = refreshStateGraph;
  window.autoGenerateStates = autoGenerateStates;
}

