// Integration layer to connect SPA with Companion Service
// This replaces the direct DOM detection with companion service polling

class CompanionIntegration {
  constructor() {
    this.companionUrl = 'http://127.0.0.1:43917';
    this.pollingInterval = 2000; // 2 seconds
    this.lastCursor = null;
    this.isPolling = false;
    this.pollingTimer = null;
  }

  async start() {
    console.log('üîå Starting companion service integration...');
    
    // Check if companion is available
    const isAvailable = await this.checkCompanionHealth();
    if (!isAvailable) {
      console.warn('‚ö†Ô∏è Companion service not available, falling back to direct detection');
      return false;
    }

    // Start polling
    this.isPolling = true;
    this.pollingTimer = setInterval(() => {
      this.pollForUpdates();
    }, this.pollingInterval);

    console.log('‚úÖ Companion integration started');
    return true;
  }

  stop() {
    if (this.pollingTimer) {
      clearInterval(this.pollingTimer);
      this.pollingTimer = null;
    }
    this.isPolling = false;
    console.log('üõë Companion integration stopped');
  }

  async checkCompanionHealth() {
    try {
      const response = await fetch(`${this.companionUrl}/health`);
      const data = await response.json();
      console.log('üè• Companion health:', data);
      return response.ok;
    } catch (error) {
      console.error('‚ùå Companion health check failed:', error);
      return false;
    }
  }

  async pollForUpdates() {
    if (!this.isPolling) return;

    try {
      const since = this.lastCursor || 0;
      const response = await fetch(`${this.companionUrl}/queue?since=${since}`);
      
      if (!response.ok) {
        console.error('‚ùå Failed to fetch queue:', response.status);
        return;
      }

      const data = await response.json();
      
      if (data.entries && data.entries.length > 0) {
        console.log(`üì• Received ${data.entries.length} entries from companion`);
        await this.processEntries(data.entries);
      }

      if (data.events && data.events.length > 0) {
        console.log(`üìä Received ${data.events.length} events from companion`);
        await this.processEvents(data.events);
      }

      // Update cursor and acknowledge
      if (data.cursor !== undefined) {
        this.lastCursor = data.cursor;
        await this.acknowledgeCursor(data.cursor);
      }

    } catch (error) {
      console.error('‚ùå Error polling companion:', error);
    }
  }

  async processEntries(entries) {
    for (const entry of entries) {
      try {
        // Convert companion entry format to our database format
        const dbEntry = {
          session_id: entry.session_id || await this.getCurrentSessionId(),
          timestamp: entry.timestamp,
          file_path: entry.file_path || '',
          prompt: entry.prompt || '',
          response: entry.response || '',
          notes: entry.notes || '',
          before_code: entry.before_code || '',
          after_code: entry.after_code || '',
          tags: this.getTagsForSource(entry.source)
        };

        // Add to database (use put for idempotency)
        await db.entries.put(dbEntry);
        console.log(`‚úÖ Added entry from companion: ${dbEntry.id}`);

        // Update search index
        if (window.searchIndex) {
          window.searchIndex.add(dbEntry);
        }

      } catch (error) {
        console.error('‚ùå Error processing entry:', error);
      }
    }

    // Re-render UI
    if (window.renderFeed) {
      await window.renderFeed();
    }
    if (window.updateStatusDashboard) {
      await window.updateStatusDashboard();
    }
  }

  async processEvents(events) {
    for (const event of events) {
      try {
        // Convert companion event format to our database format
        const dbEvent = {
          session_id: event.session_id || await this.getCurrentSessionId(),
          timestamp: event.timestamp,
          type: event.type,
          details: JSON.stringify(event.details || {})
        };

        // Add to database (use put for idempotency)
        await db.events.put(dbEvent);
        console.log(`‚úÖ Added event from companion: ${dbEvent.id}`);

      } catch (error) {
        console.error('‚ùå Error processing event:', error);
      }
    }

    // Re-render UI
    if (window.renderFeed) {
      await window.renderFeed();
    }
    if (window.updateStatusDashboard) {
      await window.updateStatusDashboard();
    }
  }

  getTagsForSource(source) {
    const tags = [];
    
    switch (source) {
      case 'filewatcher':
        tags.push('auto-detected', 'code-change');
        break;
      case 'mcp':
        tags.push('mcp-detected');
        break;
      case 'clipboard':
        tags.push('clipboard-detected');
        break;
      case 'preload':
        tags.push('preload-detected');
        break;
    }
    
    return tags;
  }

  async acknowledgeCursor(cursor) {
    try {
      await fetch(`${this.companionUrl}/ack`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ cursor })
      });
    } catch (error) {
      console.error('‚ùå Error acknowledging cursor:', error);
    }
  }

  async getCurrentSessionId() {
    // Get or create current session
    if (window.currentSession) {
      return window.currentSession.id;
    }
    
    // Create new session if none exists
    const sessionId = 'session-' + Date.now();
    const session = {
      id: sessionId,
      name: `Session ${new Date().toLocaleDateString()}`,
      created_at: new Date().toISOString()
    };
    
    await db.sessions.add(session);
    window.currentSession = session;
    
    return sessionId;
  }

  async updateCompanionConfig(config) {
    try {
      const response = await fetch(`${this.companionUrl}/config`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(config)
      });
      
      if (response.ok) {
        console.log('‚úÖ Companion config updated');
      } else {
        console.error('‚ùå Failed to update companion config');
      }
    } catch (error) {
      console.error('‚ùå Error updating companion config:', error);
    }
  }
}

// Export for use in the main app
window.CompanionIntegration = CompanionIntegration;
